// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ComputeHarmonics

#define PI            3.14159265359f
#define TWO_PI        6.28318530718f
#define FOUR_PI       12.56637061436f
#define INV_PI        0.31830988618f
#define INV_TWO_PI    0.15915494309f
#define INV_FOUR_PI   0.07957747155f
#define HALF_PI       1.57079632679f
#define INV_HALF_PI   0.636619772367f

RWStructuredBuffer<float4> SH_0_1_r;
RWStructuredBuffer<float4> SH_0_1_g;
RWStructuredBuffer<float4> SH_0_1_b;

RWStructuredBuffer<float4> SH_2_r;
RWStructuredBuffer<float4> SH_2_g;
RWStructuredBuffer<float4> SH_2_b;

RWStructuredBuffer<float4> SH_2_rgb;

TextureCube<half4> _Env;
SamplerState samplerLinearRepeat;

uint Hash(uint s)
{
    s ^= 2747636419u;
    s *= 2654435769u;
    s ^= s >> 16;
    s *= 2654435769u;
    s ^= s >> 16;
    s *= 2654435769u;
    return s;
}

float Random(uint seed)
{
    return float(Hash(seed)) / 4294967295.0; // 2^32-1
}

float3 SampleColor(float3 direction)
{   
    float4 tex = _Env.SampleLevel(samplerLinearRepeat, direction, 0);
    return tex.rgb;
}

float3 SampleDir(uint seed)
{
	const float u = Random(2 * seed);
	const float v = Random(2 * seed + 1);
	const float phi = u * PI * 2;
	const float cosTheta = 2 * v - 1;
	const float sinTheta = sqrt(1 - cosTheta * cosTheta);
	const float3 dir = float3(
		cos(phi) * sinTheta,
		sin(phi) * sinTheta,
		cosTheta
		);

	return normalize(dir);
}

float4 SH_0_1(float3 dir)
{
	const float x = 3 / 4.0 / PI * dir.x;
	const float y = 3/ 4.0 / PI * dir.y;
	const float z = 3 / 4.0 / PI * dir.z;
	const float w = 1 / 4.0 / PI;

	return float4(x, y, z, w);
}

float4 SH_2(float3 dir)
{
	const float x = 15 / 4.0 / PI * dir.x * dir.y; // -2
	const float y = 15 / 4.0 / PI * dir.y * dir.z; // -1
	const float z = 15 / 4.0 / PI * dir.x * dir.z; // 1
	const float w = 5 / 16.0 / PI * (3.0 * dir.z * dir.z - 1); // 0

	return float4(x, y, z, w);
}

[numthreads(1024, 1, 1)]
void ComputeHarmonics(uint id : SV_DispatchThreadID)
{
    const int THREADS = 1024;
    const int SAMPLES = 10;
    
    // See SH.shader for more details
    float4 results[7] = {
        float4(0, 0, 0, 0), // SH_0_1_r
        float4(0, 0, 0, 0), // SH_0_1_g
        float4(0, 0, 0, 0), // SH_0_1_b
        
        float4(0, 0, 0, 0), // SH_2_r
        float4(0, 0, 0, 0), // SH_2_g
        float4(0, 0, 0, 0), // SH_2_b
        
        float4(0, 0, 0, 0), // SH_2_rgb
    };
    
    // TASK: project light from _Env to spherical harmonic coefficients;
    // Multiply that by the same polynom coeffients, because they appear in the projection of max(0, cos(theta)) 
    // and store them in results[]


	for (int i = 0; i < SAMPLES; i++) {
		const uint seed = SAMPLES * id + i;
		const float3 dir = SampleDir(seed);
		const float3 col = SampleColor(dir);

		const float4 sh_0_1 = SH_0_1(dir);
		const float4 sh_2 = SH_2(dir);
		const float sh_2_rgb = 15 / 16.0 / PI * (dir.x * dir.x - dir.y * dir.y); // 0

		results[0] += col.r * sh_0_1;
		results[1] += col.g * sh_0_1;
		results[2] += col.b * sh_0_1;
		results[3] += col.r * sh_2;
		results[4] += col.g * sh_2;
		results[5] += col.b * sh_2;
		results[6] += float4(col, 0) * sh_2_rgb;
	}

	for (i = 0; i < 7; i++) {
		results[i] *= PI / float(SAMPLES);
	}
    
    for (int c = 0; c < 3; c++)
    {
        // Precomputing coefficients of max(0, cos(theta) for L=0
        results[c].w *= PI; 
        // Precomputing coefficients of max(0, cos(theta) for L=1
        results[c].xyz *= PI * 2 / 3;
    }
    
    for (c = 0; c < 4; c++)
    {
        // Precomputing coefficients of max(0, cos(theta) for L=2
        results[3 + c] *= PI / 4;
    } 
    
    SH_0_1_r[id] = results[0];
    SH_0_1_g[id] = results[1];
    SH_0_1_b[id] = results[2];
    
    SH_2_r[id] = results[3];
    SH_2_g[id] = results[4];
    SH_2_b[id] = results[5];    
    
	SH_2_rgb[id] = results[6];
}
